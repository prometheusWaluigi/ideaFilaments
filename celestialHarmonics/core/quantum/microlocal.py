from typing import Dict

import numpy as np


class MicrolocalAnalyzer:
    """microlocal analysis going ABSOLUTELY BUCKWILD fr fr"""

    def __init__(self, hbar: float = 1.0, window_size: int = 64):
        self.hbar = hbar
        self.window_size = window_size
        self._cache = {}  # memoization bc we EFFICIENT

    def fbi_transform(self, signal: np.ndarray, x: float, xi: float) -> complex:
        """compute that FBI transform EXPEDITIOUSLY

        Args:
            signal: input signal to analyze
            x: spatial position
            xi: frequency variable (momentum)

        Returns:
            complex FBI coefficient at (x,xi)
        """
        # gaussian window centered at x
        window = self._get_gaussian_window(x)

        # modulation by frequency xi
        modulation = np.exp(-2j * np.pi * xi * np.arange(len(signal)) / len(signal))

        # windowed fourier transform
        transformed = np.sum(signal * window * modulation) * np.sqrt(self.hbar)

        return transformed

    def wavefront_set(
        self, signal: np.ndarray, threshold: float = 0.1
    ) -> Dict[float, float]:
        """detect them singularities in phase space NO CAP

        Args:
            signal: input signal
            threshold: cutoff for wavefront detection

        Returns:
            dictionary mapping positions to frequencies in the wavefront set
        """
        wf_set = {}
        N = len(signal)

        # scan through phase space
        for x in range(N):
            max_coeff = 0
            max_xi = 0

            # check different frequencies
            for xi in range(-N // 2, N // 2):
                coeff = abs(self.fbi_transform(signal, x, xi))
                if coeff > max_coeff:
                    max_coeff = coeff
                    max_xi = xi

            # add to wavefront set if coefficient is large enough
            if max_coeff > threshold:
                wf_set[x] = max_xi * 2 * np.pi / N

        return wf_set

    def phase_space_density(self, signal: np.ndarray) -> np.ndarray:
        """compute that husimi distribution RIGOROUSLY
        basically wigner transform but make it POSITIVE"""
        N = len(signal)
        density = np.zeros((N, N))

        for x in range(N):
            for xi in range(N):
                coeff = self.fbi_transform(signal, x, xi - N // 2)
                density[x, xi] = abs(coeff) ** 2

        return density / np.sum(density)  # normalize that EXPEDITIOUSLY

    def _get_gaussian_window(self, center: float) -> np.ndarray:
        """get that gaussian window EFFICIENTLY using cache"""
        if center in self._cache:
            return self._cache[center]

        x = np.arange(self.window_size)
        window = np.exp(-((x - center) ** 2) / (2 * self.hbar))
        window = window / np.sqrt(np.sum(window**2))  # normalize

        self._cache[center] = window
        return window


def compute_quantum_metrics(signal: np.ndarray, hbar: float = 1.0) -> Dict[str, float]:
    """compute them quantum metrics EXPEDITIOUSLY"""
    analyzer = MicrolocalAnalyzer(hbar=hbar)

    # get phase space density
    density = analyzer.phase_space_density(signal)

    # compute quantum entropy
    entropy = -np.sum(density * np.log(density + 1e-10))

    # get wavefront complexity
    wf_set = analyzer.wavefront_set(signal)
    complexity = len(wf_set)

    # compute phase space localization
    x_mean = np.sum(np.arange(len(density)) * np.sum(density, axis=1))
    p_mean = np.sum(np.arange(len(density)) * np.sum(density, axis=0))
    x_var = np.sum((np.arange(len(density)) - x_mean) ** 2 * np.sum(density, axis=1))
    p_var = np.sum((np.arange(len(density)) - p_mean) ** 2 * np.sum(density, axis=0))

    return {
        "quantum_entropy": float(entropy),
        "wavefront_complexity": complexity,
        "uncertainty_product": float(np.sqrt(x_var * p_var)),
        "phase_space_volume": float(np.sum(density > 0.01)),  # effective support
    }
